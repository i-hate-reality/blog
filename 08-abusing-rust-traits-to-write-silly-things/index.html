<!DOCTYPE html>
<html lang="en">

<head>
    <title>(Ab)using Rust traits to write silly things</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>
    <meta name="author" content="Maybe Waffle">

    <meta name="theme-color" content="#EE72F1">

    
    
    <meta name="title" content="(Ab)using Rust traits to write silly things">
    <meta name="description" content="Explaining how to make a function that is callable with and without parentheses">
    <meta name="image" content="https://blog.ihatereality.space/you_cant_escape_from_reality_450x450.png">

    
        <meta name="keywords" itemprop="tags" content="rust">
    

    <!-- Facebook Meta Tags -->
    <meta property="og:url" content="https://blog.ihatereality.space/08-abusing-rust-traits-to-write-silly-things/">
    <meta property="og:type" content="article">
    <meta property="og:title" content="(Ab)using Rust traits to write silly things">
    <meta property="og:description" content="Explaining how to make a function that is callable with and without parentheses">
    <meta property="og:image" content="https://blog.ihatereality.space/you_cant_escape_from_reality_450x450.png">
    <meta property="og:locale" content="en">

    
        <meta property="article:published_time" content="2022-06-29">
    

    
        
            <meta property="article:tag" content="rust">
        
    

    <!-- Twitter Meta Tags -->
    <meta name="twitter:card" content="summary">
    <meta property="twitter:domain" content="blog.ihatereality.space">
    <meta property="twitter:url" content="https://blog.ihatereality.space/08-abusing-rust-traits-to-write-silly-things/">
    <meta name="twitter:title" content="(Ab)using Rust traits to write silly things">
    <meta name="twitter:description" content="Explaining how to make a function that is callable with and without parentheses">
    <meta name="twitter:image" content="https://blog.ihatereality.space/you_cant_escape_from_reality_450x450.png">
    <meta name="twitter:creator" content="maybewaffle">



    
    <link rel="stylesheet" href="https://blog.ihatereality.space/style.css">
    <link rel="stylesheet" href="https://blog.ihatereality.space/color/pink.css">

    <link rel="stylesheet" href="https://blog.ihatereality.space/font-hack.css">


    
        <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.ihatereality.space/rss.xml">
    
        <link rel="shortcut icon" type="image&#x2F;png" href="/you_cant_escape_from_reality_128x128.png">
    
    </head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://blog.ihatereality.space" style="text-decoration: none;">
                    <div class="logo">
                            I hate reality
                        </div>
                </a>
            </div>
        </div>

        
    <nav class="menu">
            <ul class="menu__inner">
                <li><a href="https://blog.ihatereality.space/about">about</a></li>
            
                <li><a href="https://github.com/iloathereality/blog" target="_blank" rel="noopener noreferrer">source</a></li>
            </ul>
        </nav>
    

    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://blog.ihatereality.space/08-abusing-rust-traits-to-write-silly-things/">(Ab)using Rust traits to write silly things</a></h1>
    
        <div class="post-meta-inline">
            
    <span class="post-date">
            2022-06-29
        
    </span>

            
    <span class="post-read-time">
        :: 9 min read
    </span>


            <!-- TODO: rethink how tags look -->
            <br>
            
        <span class="post-tags-inline"><a class="post-tag" href="https://blog.ihatereality.space/tags/rust/">#rust</a></span>
    
        </div>
    


        
        <div class="post-content">
            <p>Recently I’ve found some cursed Rust code and decided to make a little joke/question <a href="https://twitter.com/maybewaffle/status/1541910667812274183">on twitter</a>.
In the tweet I’ve presented some unusual code and asked “how could it compile?”.
The solution was found quite fast by <a href="https://twitter.com/Veykril">@Veykril</a> (kudos to them!) and in this post I want to explain it in detail.</p>
<span id="continue-reading"></span><h1 id="the-joke-question">The joke/question<a class="zola-anchor" href="#the-joke-question" aria-label="Anchor link for: the-joke-question">⌗</a></h1>
<p>So in the tweet I’ve presented the following code:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">for</span><span> x in lib::iter::&lt;</span><span style="color:#b48ead;">u32</span><span>&gt; {
</span><span>        </span><span style="color:#b48ead;">let </span><span>_: </span><span style="color:#b48ead;">u32 </span><span>= x; </span><span style="color:#65737e;">// assert that `x` has type u32
</span><span>    }
</span><span>    
</span><span>    </span><span style="color:#b48ead;">for</span><span> y in lib::iter::&lt;String&gt;() {
</span><span>        </span><span style="color:#b48ead;">let </span><span>_: String = y;
</span><span>    }
</span><span>    
</span><span>    </span><span style="color:#b48ead;">for</span><span> z in lib::iter { </span><span style="color:#65737e;">// infer type
</span><span>        </span><span style="color:#b48ead;">let </span><span>_: &amp;</span><span style="color:#b48ead;">&#39;static str </span><span>= z;
</span><span>    }
</span><span>    
</span><span>    </span><span style="color:#b48ead;">for</span><span> k in lib::iter() {
</span><span>        </span><span style="color:#b48ead;">let </span><span>_: </span><span style="color:#b48ead;">f64 </span><span>= k;
</span><span>    }
</span><span>}
</span></code></pre>
<p>That compiles with <strong>stable compiler</strong>, if you have a right <code>lib</code>!
The interesting bit here is of course that function <code>lib::iter</code> can be called with or without parentheses. 
This is normally not possible, so what is going on?</p>
<p>First of all, some low hanging fruit: <code>for</code> loops in Rust desugar to something like this:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// Original
</span><span style="color:#b48ead;">for</span><span> x in i { </span><span style="color:#96b5b4;">f</span><span>(x); }
</span></code></pre>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// Desugaring
</span><span>{
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> iter = IntoIterator::into_iter(i);
</span><span>    </span><span style="color:#b48ead;">while let </span><span>Some(x) = iter.</span><span style="color:#96b5b4;">next</span><span>() { </span><span style="color:#96b5b4;">f</span><span>(x); }
</span><span>    </span><span style="color:#65737e;">// while let itself desugars to loop+match,
</span><span>    </span><span style="color:#65737e;">// but that&#39;s not the point
</span><span>}
</span></code></pre>
<p>So before iteration starts <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html#tymethod.into_iter"><code>into_iter</code></a> is called.
Which allows you to pass any type implementing <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>, not just <code>Iterator</code>s.
That’s just to say that we need <code>iter</code> and <code>iter()</code> somehow evaluate to type(s) that implement <code>IntoIterator</code>.</p>
<p>As a side note: on nightly there is a trait <a href="https://doc.rust-lang.org/std/future/trait.IntoFuture.html"><code>IntoFuture</code></a> that is just like <code>IntoIterator</code>, but for futures and is used for <code>.await</code> desugaring.
You can do all the same stuff with it, so async functions with optional <code>()</code> are possible too:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![</span><span style="color:#bf616a;">feature</span><span>(into_future)]
</span><span>async </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">_f</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let </span><span>_: String = lib2::fut::&lt;String&gt;.await;
</span><span>    </span><span style="color:#b48ead;">let </span><span>_: [</span><span style="color:#b48ead;">u8</span><span>; </span><span style="color:#d08770;">2</span><span>] = lib2::fut::&lt;[</span><span style="color:#b48ead;">u8</span><span>; </span><span style="color:#d08770;">2</span><span>]&gt;().await;
</span><span>    </span><span style="color:#b48ead;">let </span><span>_: &amp;</span><span style="color:#b48ead;">str </span><span>= lib2::fut.await;
</span><span>    </span><span style="color:#b48ead;">let </span><span>_: </span><span style="color:#b48ead;">u128 </span><span>= lib2::fut().await;
</span><span>}
</span></code></pre>
<p>BTW I think it <a href="https://github.com/rust-lang/rust/issues/67644#issuecomment-1163424241">should be stabilized</a> soon, so keep an eye on the tracking issue (or don’t (I’m just very excited for this feature)).</p>
<p>But, this all still leaves us with a question: how can functions be called without parenthesis?</p>
<h1 id="tempting-idea-that-doesn-t-work">Tempting idea that doesn’t work<a class="zola-anchor" href="#tempting-idea-that-doesn-t-work" aria-label="Anchor link for: tempting-idea-that-doesn-t-work">⌗</a></h1>
 


  

  
    
  


<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>The title of this section is concerning, but why can’t we just make a <code>const</code>+<code>impl IntoIterator for fn()</code>?</p>

  </div>
</div>
<p>So the idea is to write something like this:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">const</span><span> iter: </span><span style="color:#b48ead;">fn</span><span>() -&gt; Iter = || Iter;
</span><span style="color:#b48ead;">impl </span><span>IntoIterator </span><span style="color:#b48ead;">for </span><span>fn() -&gt; Iter { </span><span style="color:#65737e;">/* not important */ </span><span>}
</span><span>
</span><span style="color:#b48ead;">struct </span><span>Iter;
</span><span style="color:#b48ead;">impl </span><span>Iterator </span><span style="color:#b48ead;">for </span><span>Iter {}
</span></code></pre>
<p>Then <code>for _ in iter {}</code> would work because of the <code>IntoIterator</code> impl
and <code>for _ in iter() {}</code> would work because <code>iter</code>’s type is a <a href="https://doc.rust-lang.org/stable/std/primitive.fn.html">function pointer</a> that returns a type that implements <code>Iterator</code>.</p>
<p>But… this doesn’t work for the following two reasons:</p>
<ol>
<li>You can’t implement a foreign trait (<code>IntoIterator</code>) for a foreign type (<code>fn() -&gt; _</code>) and standard library doesn’t (yet?) implement <code>IntoIterator</code> for function pointers.
(you could patch <code>std</code> but then this won’t work with the stable compiler)</li>
<li>Constants can’t have generic parameters! So <code>iter::&lt;T&gt;</code> won’t work.</li>
</ol>
<p>So, we need to find something else to (ab)use.</p>
<h1 id="hack-1">Hack #1<a class="zola-anchor" href="#hack-1" aria-label="Anchor link for: hack-1">⌗</a></h1>
 


  

  
    
  


<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>Uh? There are multiple hacks at play here already?</p>

  </div>
</div>
<p>Yes! There is a hack for <code>iter::&lt;T&gt;</code> and for <code>iter::&lt;T&gt;()</code>, we’ll start with the former.</p>
<p><code>iter::&lt;T&gt;</code> looks a lot like a unit structure with a generic parameter. </p>
 


  

  
    
  


<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>Maybe it <strong>is</strong> a unit structure with a generic parameter?</p>

  </div>
</div>
<p>If only things were that simple…
In Rust you need to use all generic parameters in the type, or else your code won’t compile:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">struct </span><span>S&lt;T&gt;(</span><span style="color:#b48ead;">u8</span><span>);
</span><span style="color:#65737e;">//~^ error: parameter `T` is never used
</span><span style="color:#65737e;">//~| help: consider removing `T`, referring to it in a field, or using a marker such as `PhantomData`
</span><span style="color:#65737e;">//~| help: if you intended `T` to be a const parameter, use `const T: usize` instead
</span></code></pre>
<p>This is because compiler wants to infer <a href="https://doc.rust-lang.org/nomicon/subtyping.html">variance</a> of all parameters.
Since a unit structure, by definition, doesn’t have any fields, you can’t use generic parameters in it!</p>
 


  

  
    
  


<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>Wait, compiler mentioned <code>PhantomData</code>, isn’t that a unit structure with a generic parameter?…</p>

  </div>
</div>
<p>It is! </p>
 


  

  
    
  


<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>So I assume we can’t use it because we can’t impl <code>IntoIterator</code> for it either.
But why can’t we copy its definition into our code?</p>

  </div>
</div>
<p>Well… just look at its definition:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">lang </span><span>= &quot;</span><span style="color:#a3be8c;">phantom_data</span><span>&quot;] </span><span style="color:#65737e;">// &lt;-- *compiler magic*
</span><span style="color:#b48ead;">pub struct </span><span>PhantomData&lt;T: </span><span style="background-color:#bf616a;color:#2b303b;">?</span><span>Sized&gt;;
</span></code></pre>
 


  

  
    
  


<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>Oh.</p>

  </div>
</div>
<p>Yeah…</p>
<p>So, there is no way around this, to define a <code>PhantomData</code>-like type, we need to do something hacky…
A hack to do this I first saw implemented by dtolnay (not surprising, is it?) in their crate <a href="https://github.com/dtolnay/ghost"><code>ghost</code></a>.</p>
<p>The hack basically looks like this:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">mod </span><span>imp {
</span><span>    </span><span style="color:#b48ead;">pub enum </span><span>Void {}
</span><span>
</span><span>    </span><span style="color:#b48ead;">pub enum </span><span>Type&lt;T&gt; {
</span><span>        Type,
</span><span>        __Phantom(T, Void),
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">pub mod </span><span>reexport_hack {
</span><span>        </span><span style="color:#b48ead;">pub use super</span><span>::Type::Type;
</span><span>    }
</span><span>}
</span><span>
</span><span>#[</span><span style="color:#bf616a;">doc</span><span>(hidden)]
</span><span style="color:#b48ead;">pub use </span><span>imp::reexport_hack::*;
</span><span style="color:#b48ead;">pub type </span><span>Type&lt;T&gt; = imp::Type&lt;T&gt;;
</span></code></pre>
 


  

  
    
  


<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>Wha-</p>

  </div>
</div>
<p>It may seem convoluted at first, but it’s actually quite simple!</p>
<p>So, let’s unpack this item-by-item:</p>
<ol>
<li><code>pub enum Void {}</code> defines a type with no values, also known as uninhabited type. 
The nice property for us is that values of this type can’t be created.
That is basically a stable replacement for the <a href="https://doc.rust-lang.org/stable/std/primitive.never.html"><code>!</code></a> type.</li>
<li><code>Type&lt;T&gt;</code> has two variants: unit variant <code>Type</code> and a struct variant <code>__Phantom(T, Void)</code>.
The latter uses <code>T</code>, solving the “parameter <code>T</code> is never used” error
while simultaneously being impossible to construct because of the <code>Void</code> field.
Since <code>__Phantom</code> variant is impossible to create / uninhabited, 
<code>Type&lt;_&gt;</code> effectively has only a single usable variant.</li>
<li><code>reexport_hack</code> reexports <code>Type::Type</code> (variant <code>Type</code> of the type <code>Type</code>)</li>
<li><code>pub use imp::reexport_hack::*;</code> is a glob reexport that reexports <code>Type::Type</code> 
that was reexported by <code>reexport_hack</code>.
I’m not entirely sure why, but using glob is important.</li>
<li><code>pub type Type&lt;T&gt; = imp::Type&lt;T&gt;;</code> basically reexports the <code>Type</code> itself.
It’s just rendered in docs in a nicer way than if reexported by <code>pub use</code></li>
</ol>
<p>And now the magic: <code>Type</code> now refers both to the type <strong>and</strong> to the variant.
This works because Rust has different namespaces for types and values.
Glob reexport somehow suppresses an error about clashing names that arises when importing directly.
Idk why it’s this way :shrug:</p>
<p>Ah, and <code>let _ = Type::&lt;u8&gt;</code> works because you can apply generic parameters to variants.
It’s the same way as <code>None::&lt;Fish&gt;</code> is an expression of type <code>Option&lt;Fish&gt;</code>
or <code>Ok::&lt;_, E&gt;(())</code> is an expression of type <code>Result&lt;(), E&gt;</code>.</p>
 


  

  
    
  


<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>That’s a lot… But I think I’ve grasped the concept</p>

  </div>
</div>
<p>With this hack, you can define types that are indistinguishable from <code>PhantomData</code>!
And this time we can use it to define an <code>iter&lt;_&gt;</code> “unit struct”:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub type </span><span>iter&lt;T&gt; = imp::iter&lt;T&gt;;
</span><span style="color:#b48ead;">pub use </span><span>imp::reexport_hack::*;
</span><span>
</span><span style="color:#b48ead;">impl</span><span>&lt;T&gt; IntoIterator </span><span style="color:#b48ead;">for </span><span>iter&lt;T&gt; {
</span><span>    </span><span style="color:#b48ead;">type </span><span>Item = T;
</span><span>    </span><span style="color:#b48ead;">type </span><span>IntoIter = Iter&lt;T&gt;; 
</span><span>    </span><span style="color:#65737e;">// capitalized -^
</span><span>}
</span><span>
</span><span style="color:#b48ead;">struct </span><span>Iter&lt;T&gt;(...);
</span><span style="color:#b48ead;">impl</span><span>&lt;T&gt; Iterator </span><span style="color:#b48ead;">for </span><span>Iter&lt;T&gt; { </span><span style="color:#65737e;">/* not that important */ </span><span>}
</span><span>
</span><span style="color:#b48ead;">mod </span><span>imp { </span><span style="color:#65737e;">/* basically the same as before */</span><span>}
</span></code></pre>
<p>This already allows us to do cool stuff like this:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">for</span><span> x in lib::iter::&lt;</span><span style="color:#b48ead;">u32</span><span>&gt; {
</span><span>    </span><span style="color:#b48ead;">let </span><span>_: </span><span style="color:#b48ead;">u32 </span><span>= x; </span><span style="color:#65737e;">// assert that `x` has type u32
</span><span>}
</span><span>
</span><span style="color:#b48ead;">for</span><span> z in lib::iter { </span><span style="color:#65737e;">// infer type
</span><span>    </span><span style="color:#b48ead;">let </span><span>_: &amp;</span><span style="color:#b48ead;">&#39;static str </span><span>= z;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">let</span><span> iter: lib::iter&lt;()&gt; = lib::iter::&lt;()&gt;;
</span><span style="color:#65737e;">//     type ---^^^^^^^^        ^^^^^^^^^^--- constant
</span></code></pre>
<p>Now to the next hack, that would allow us to call <code>iter</code> too instead of using it as a constant!</p>
<h1 id="hack-2">Hack #2<a class="zola-anchor" href="#hack-2" aria-label="Anchor link for: hack-2">⌗</a></h1>
 


  

  
    
  


<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>I want to make a guess of what we’ll do!!</p>

  </div>
</div>
<p>Uh ok, go ahead!</p>
 


  

  
    
  


<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>So I’ve heard that in Rust all functions and closures have unique types.
And the ability to call these types with <code>()</code> is controlled via <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a> and <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a> traits.
Can we just implement these traits for <code>iter&lt;T&gt;</code>?</p>

  </div>
</div>
<p>We could! But we can’t.
These traits are unstable and I’m in the stable-compiler jail today.</p>
 


  

  
    
  


<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>Oh… Okay then… Do you have another “impossible to guess if haven’t seen before” kind of thing?</p>

  </div>
</div>
<p>Kind of!
We can (ab)use <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a> trait:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl</span><span>&lt;T&gt; Deref </span><span style="color:#b48ead;">for </span><span>iter&lt;T&gt; {
</span><span>    </span><span style="color:#b48ead;">type </span><span>Target = </span><span style="color:#b48ead;">fn</span><span>() -&gt; Iter&lt;T&gt;;
</span><span>    
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">deref</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) -&gt; &amp;</span><span style="color:#b48ead;">Self::</span><span>Target {
</span><span>        &amp;((|| Iter([])) as _)
</span><span>    }
</span><span>}
</span></code></pre>
<p>Normally <code>Deref</code> is used for smart pointers like <code>Box</code> or <code>Arc</code> so that</p>
<ul>
<li>You can use the dereference operator on them (<code>*my_beloved_arc</code>)</li>
<li>You can call methods of the inner type (<code>my_beloved_arc.nice()</code>)</li>
</ul>
<p>This makes a lot of sense because smart pointers still just point to values and it’s nice to be able to just call methods.</p>
<p><strong>But!</strong></p>
<p>There is nothing stopping you from implementing <code>Deref</code> for non-smart pointer types (besides, what <em>is</em> a smart pointer?).
And so abnormally <code>Deref</code> is used to forward methods.</p>
 


  

  
    
  


<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>Is this considered a bad practice?</p>

  </div>
</div>
<p>Uh well mmm yemmm aaa phhhh mmm… mh.. yes? But everyone uses it anyway.
It’s even used this way in the <a href="https://github.com/rust-lang/rust/blob/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71/compiler/rustc_errors/src/diagnostic_builder.rs#L275">compiler itself</a>, so who cares?</p>
<p>Ok, so what was I- Ah, right, and what came as a surprise to me, when you are writing <code>f()</code> deref coercions can deref <code>f</code> too!
So <code>f()</code> can become more like <code>(&amp;*f)()</code> or in other words <code>f.deref()()</code>.
This means that by implementing deref to a function pointer for our <code>iter&lt;T&gt;</code> we can allow to call it!</p>
<p>Full code is on the <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=d2643f25de8d2cc6beb9d009f01d1ba3">playground</a> if you want to play with it.</p>
<p>That’s all I have for today, two hacks that I saw used <a href="https://github.com/dtolnay/inventory/blob/e105c33023492a443b53a58cd6ab0230d0434138/src/lib.rs#L261">“in the wild”</a> (right, this one is also by dtolnay) and thought that it’s quite surprising and fun thing.</p>
<p>bye.</p>

        </div>

        
        <div class="pagination">
            <div class="pagination__title">
                <span class="pagination__title-h">Thanks for reading! Read other posts?</span>
                <hr />
            </div>
            <div class="pagination__buttons">
                    <span class="button previous">
                        <a href="https://blog.ihatereality.space/devlog-00/">
                            <span class="button__icon">←</span>&nbsp;
                            <span class="button__text">Waffle Devlog 0</span>
                        </a>
                    </span>
                
                
                    <span class="button next">
                        <a href="https://blog.ihatereality.space/07-why-we-can-not-have-nice-things-min-max/">
                            <span class="button__text">Why we can’t have nice things: min&#x2F;max</span>&nbsp;
                            <span class="button__icon">→</span>
                        </a>
                    </span>
                </div>
        </div>
    
    </div>

    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright copyright--user"><div class="copyright"><span>© 2021-2024 Waffle Lapkin</span><span class="copyright-theme"><span class="copyright-theme-sep">:: </span>Theme is based on <a href="https://github.com/pawroman/zola-theme-terminimal/">Terminimal</a></span><span class="copyright-theme-sep">:: </span><a href="/rss.xml">rss</a></div></div>
            </div>
    </footer>
    

</div>

<!-- Tracking via https://www.goatcounter.com/ -->
<script data-goatcounter="https://ihr.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</body>

</html>
