<!DOCTYPE html>
<html lang="en">

<head>
    <title>Why null sucks, even if it&#x27;s checked</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>
    <meta name="author" content="Maybe Waffle">

    <meta name="theme-color" content="rgb(238,114,241)">

    
    <meta name="title" content="Why null sucks, even if it&#x27;s checked">
    <meta name="description" content="We all know that `null` is a &quot;billion-dollar mistake&quot;, that it creates a lot of easy ways to make terrible mistakes. But it&#x27;s only so bad when it&#x27;s not checked by anyone and the compiler doesn&#x27;t force you to check it, right? Well, the title might be a spoiler, but let&#x27;s find out...">

    
        <meta name="keywords" itemprop="tags" content="kotlin, csharp, haskell, rust, go">
    

    <!-- Facebook Meta Tags -->
    <meta property="og:url" content="https://ihatereality.space/01-why-null-sucks/">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Why null sucks, even if it&#x27;s checked">
    <meta property="og:description" content="We all know that `null` is a &quot;billion-dollar mistake&quot;, that it creates a lot of easy ways to make terrible mistakes. But it&#x27;s only so bad when it&#x27;s not checked by anyone and the compiler doesn&#x27;t force you to check it, right? Well, the title might be a spoiler, but let&#x27;s find out...">
    <meta property="og:locale" content="en">

    
        <meta property="article:published_time" content="2021-08-20">
    

    
        
            <meta property="article:tag" content="kotlin">
        
            <meta property="article:tag" content="csharp">
        
            <meta property="article:tag" content="haskell">
        
            <meta property="article:tag" content="rust">
        
            <meta property="article:tag" content="go">
        
    

    <!-- Twitter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="ihatereality.space">
    <meta property="twitter:url" content="https://ihatereality.space/01-why-null-sucks/">
    <meta name="twitter:title" content="Why null sucks, even if it&#x27;s checked">
    <meta name="twitter:description" content="We all know that `null` is a &quot;billion-dollar mistake&quot;, that it creates a lot of easy ways to make terrible mistakes. But it&#x27;s only so bad when it&#x27;s not checked by anyone and the compiler doesn&#x27;t force you to check it, right? Well, the title might be a spoiler, but let&#x27;s find out...">
    <meta name="twitter:creator" content="maybewaffle">



    
    <link rel="stylesheet" href="https://ihatereality.space/style.css">
    <link rel="stylesheet" href="https://ihatereality.space/color/pink.css">

    <link rel="stylesheet" href="https://ihatereality.space/font-hack.css">


    
        <link rel="alternate" type="application/rss+xml" title="RSS" href="https://ihatereality.space/rss.xml">
    
        <link rel="shortcut icon" type="image&#x2F;png" href="/you_cant_escape_from_reality_128x128.png">
    
    </head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://ihatereality.space" style="text-decoration: none;">
                    <div class="logo">
                            I hate reality
                        </div>
                </a>
            </div>
        </div>

        <nav class="menu">
            <ul class="menu__inner">
                <li><a href="https://ihatereality.space/about">about</a></li>
            
                <li><a href="https://ihatereality.space/tags">tags</a></li>
            
                <li><a href="https://github.com/iloathereality/blog" target="_blank" rel="noopener noreferrer">source</a></li>
            </ul>
        </nav>
    
    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://ihatereality.space/01-why-null-sucks/">Why null sucks, even if it&#x27;s checked</a></h1>
    
        <div class="post-meta-inline">
            
    <span class="post-date">
            2021-08-20
        
            [updated 2021-08-25]
        
    </span>

            
    <span class="post-read-time">
        :: 13 min read
    </span>


            <!-- TODO: rethink how tags look -->
            <br>
            
        <span class="post-tags-inline"><a class="post-tag" href="https://ihatereality.space/tags/kotlin/">#kotlin</a> <a class="post-tag" href="https://ihatereality.space/tags/csharp/">#csharp</a> <a class="post-tag" href="https://ihatereality.space/tags/haskell/">#haskell</a> <a class="post-tag" href="https://ihatereality.space/tags/rust/">#rust</a> <a class="post-tag" href="https://ihatereality.space/tags/go/">#go</a></span>
    
        </div>
    


        
        <div class="post-content">
            <p>We all know that <code>null</code> is a <a href="https://en.wikipedia.org/wiki/Null_pointer#History">“billion-dollar mistake”</a>, that it creates a lot of easy ways to make terrible mistakes. But it’s only so bad when it’s not checked by anyone and the compiler doesn’t force you to check it, right? Well, the title might be a spoiler, but let’s find out…</p>
<span id="continue-reading"></span><h2 id="context-what-are-you-talking-about">Context / What are you talking about?</h2>
<p>In this article, I’m specifically talking about the <a href="https://kotlinlang.org/docs/null-safety.html">Kotlin</a> and <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#nullable-reference-types">C# post v8</a> approach to <code>null</code>. I’m more familiar with Kotlin than C#, so I’ll mostly be talking about it, but their approaches are similar, so that doesn’t really matter.</p>
<p>Basically, you can’t assign null to just any reference type in Kotlin (and C# post v8 with certain settings). For example, this is a compilation error:</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#65737e;">// compilation error
</span><span style="color:#b48ead;">val </span><span>a: </span><span style="color:#b48ead;">String </span><span>= </span><span style="color:#d08770;">null</span><span>;
</span><span>
</span><span style="color:#65737e;">// ok
</span><span style="color:#b48ead;">var </span><span>b: </span><span style="color:#b48ead;">String </span><span>= &quot;</span><span style="color:#a3be8c;">not null</span><span>&quot;;
</span><span>
</span><span style="color:#65737e;">// compilation error (again)
</span><span>b = </span><span style="color:#d08770;">null</span><span>;
</span></code></pre>
<p>And since you can’t assign <code>null</code> to non-nullable types, <code>null</code> can’t screw you! You can’t get a null pointer (reference) exception, etc. Cool!</p>
<p>If you really want to assign null to something, you need to explicitly mark the type of the variable as nullable with <code>T?</code> syntax:</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#65737e;">// ok
</span><span style="color:#b48ead;">val </span><span>a: </span><span style="color:#b48ead;">String</span><span>? = </span><span style="color:#d08770;">null</span><span>;
</span><span>
</span><span style="color:#65737e;">// also ok
</span><span style="color:#b48ead;">var </span><span>b: </span><span style="color:#b48ead;">String</span><span>? = &quot;</span><span style="color:#a3be8c;">not null</span><span>&quot;;
</span><span>b = </span><span style="color:#d08770;">null</span><span>;
</span></code></pre>
<p>But when you have a <code>T?</code> (nullable) type, you also need to explicitly check for null. E.g. given a class <code>Mine</code> with a <code>cat</code> field and a variable <code>mine</code> of type <code>Mine?</code>, you can’t access <code>mine.cat</code>, it would be a compilation error:</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">val </span><span>mine: Mine? = </span><span style="color:#65737e;">/* ... */
</span><span style="color:#b48ead;">val </span><span>your: Mine  = </span><span style="color:#65737e;">/* ... */
</span><span>
</span><span style="color:#65737e;">// compilation error
</span><span style="color:#b48ead;">val </span><span>a: Cat = mine.cat
</span><span>
</span><span style="color:#65737e;">// elvis operator, if `mine` is null,
</span><span style="color:#65737e;">// then `your` will be used
</span><span style="color:#b48ead;">val </span><span>b: Cat = (mine ?: your).cat  
</span><span>
</span><span style="color:#65737e;">// safe call operator, if `mine` is null, 
</span><span style="color:#65737e;">// then so be `c`        
</span><span style="color:#b48ead;">val </span><span>c: Cat? = mine?.cat
</span><span>
</span><span style="color:#65737e;">// “trust me, I&#39;m an engineer” operator, 
</span><span style="color:#65737e;">// throws an exception if `mine` is null 
</span><span style="color:#b48ead;">val </span><span>d: Cat = mine!!.cat
</span><span>
</span><span style="color:#b48ead;">if</span><span> mine != </span><span style="color:#d08770;">null</span><span> {
</span><span>    </span><span style="color:#65737e;">// Special Kotlin trick: 
</span><span>    </span><span style="color:#65737e;">// in this block `mine` actually has type `Mine`.
</span><span>
</span><span>    </span><span style="color:#65737e;">// perfectly fine (we&#39;ve checked)
</span><span>    </span><span style="color:#b48ead;">val </span><span>x: Cat = mine.cat
</span><span>}
</span></code></pre>
<p>(The same applies for calling a function with an argument of non-nullable type, you need to either check that something is not null or explicitly assume so)</p>
<p>The “special kotlin trick” is called “smart cast”. Basically, if you check that a variable is not null (or has a particular type), then the compiler changes type of the variable in the block, where the check holds. You can read more about it in Kotlin docs: <a href="https://kotlinlang.org/docs/typecasts.html#smart-casts">typecasts</a>, <a href="https://kotlinlang.org/docs/null-safety.html#checking-for-null-in-conditions">null-safety</a>.</p>
<p>And it’s all great, don’t get me wrong! This behaviour is a lot better than the plain old “every reference can be null, just crash if it is and it’ll be fine”. However…</p>
<h2 id="why-it-s-still-meh">Why it’s still meh</h2>
<p>In my opinion, this comes down to 2 things: generality and extensibility.</p>
<h3 id="generality">Generality</h3>
<p>In modern languages, we have ways to abstract over types. Usually, the mechanism to do so is called generics. For example, a <code>HashMap</code> doesn’t care what the key and value types are, it only cares that the key is comparable and hashable. Thus you can have <code>HashMap&lt;String, i32&gt;</code>, <code>HashMap&lt;User, Settings&gt;</code>, etc while only writing <code>HashMap</code> once. </p>
<p>That’s all good and all, but what’s the problem? You may ask. Well… Consider this example: the <code>HashMap</code> has a method <code>get</code> which accepts key and returns the value associated with the key if there is one. But what should it return if there is no value associated with the key? It seems reasonable to return <code>null</code> since there is no value. So something like this:</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">HashMap</span><span>&lt;</span><span style="color:#b48ead;">K</span><span>, </span><span style="color:#b48ead;">V</span><span>&gt; {
</span><span>    </span><span style="color:#65737e;">// If `key` is present in the hash map, 
</span><span>    </span><span style="color:#65737e;">// returns the value associated with it. 
</span><span>    </span><span style="color:#65737e;">// Otherwise returns `null`.
</span><span>    </span><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">get</span><span>(key: K): V? { </span><span style="color:#65737e;">/* ... */</span><span> }
</span><span>}
</span></code></pre>
<p>But what happens if we use <code>HashMap&lt;_, T?&gt;</code>? Well, then <code>V</code> is <code>T?</code> and so <code>V?</code> is <code>T??</code> which is the same as <code>T?</code> because there is only one <code>null</code> value. </p>
<p>The crux of the problem is this: you can’t distinguish between “absence of value” (no key in the map) and “presence of absence of value” (value is <code>null</code>). And if you need to distinguish them, then you need to call <code>containsKey</code> or something which is suboptimal.</p>
<p>This is just a simple example, but in general, you can’t use <code>null</code> in generic code because <code>null</code> is too special and <strong>unique</strong>.</p>
<h3 id="extensibility">Extensibility</h3>
<p><code>null</code> is not extensible. This mechanism is only useful when you have an optional value: either there is a value, or there isn’t. </p>
<p>It isn’t useful when you need to express errors (<code>null</code> is used for this anyway, but this is problematic), exclusive or (either you have <code>A</code> or <code>B</code>, but not both and not neither), etc. </p>
<p>It may seem like this isn’t a problem — we were talking about expressing optional values from the very beginning. But bear with me, and for now just understand that <code>null</code> is not extensible and there may be other, more extensible, mechanisms.</p>
<h2 id="the-saviour">The saviour?</h2>
<p>As I said before, there may be a more general and extensible way to handle optional values. And there is! It has a lot of different names — sum types, enumerations, tagged unions, discriminated unions, etc. They’re all conceptually similar, but I like the “sum types” name the most, so that’s what I’ll call it.</p>
<p>In any case, the concept stays the same — a type that can represent one out of multiple choices. Here are some well-known examples of definitions of sum types:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">enum </span><span>Option&lt;T&gt; { None, Some(T) }
</span><span style="color:#b48ead;">enum </span><span>Either&lt;L, R&gt; { Left(L), Right(R) }
</span></code></pre>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">data </span><span style="color:#d08770;">Maybe</span><span> a = </span><span style="color:#d08770;">Nothing </span><span>| </span><span style="color:#d08770;">Just</span><span> a
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">Either</span><span> a b = </span><span style="color:#d08770;">Left</span><span> a | </span><span style="color:#d08770;">Right</span><span> b
</span></code></pre>
<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>I’ve shown examples in Rust and Haskell because I’m familiar with them but note that sum types exist in <a href="https://en.wikipedia.org/wiki/Algebraic_data_type#Programming_languages_with_algebraic_data_types">many languages</a>. </p>

  </div>
</div>
<p><code>Option</code> (<code>Maybe</code>) is exactly what we’re looking for! It can be either <code>None</code> (<code>Nothing</code>) or <code>Some(value)</code> (<code>Just value</code>). So either there is nothing or there is some value, exactly the same as with <code>null</code> so far. </p>
<p>But it actually solves all the <code>null</code> problems I’ve mentioned!</p>
<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>Another nice fact about <code>Option</code> (<code>Maybe</code>) is that it can be defined in a library. Unlike nullable types, there’s nothing special about this type. The compiler doesn’t need to know about it, it’s just a type.</p>

  </div>
</div>
<h3 id="generality-1">Generality</h3>
<p><code>Option&lt;Option&lt;T&gt;&gt;</code> is a meaningful type, unlike <code>T??</code>. In the same example with <code>HashMap::get</code> there isn’t any problems if it returns <code>Option&lt;_&gt;</code>.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl</span><span>&lt;K, V&gt; HashMap&lt;K, V&gt; {
</span><span>    </span><span style="color:#65737e;">// If `key` is present in the hash map, 
</span><span>    </span><span style="color:#65737e;">// returns the value associated with it. 
</span><span>    </span><span style="color:#65737e;">// Otherwise returns `None`.
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">key</span><span>: &amp;K) -&gt; Option&lt;V&gt; { </span><span style="color:#65737e;">/* ... */ </span><span>}
</span><span>}
</span></code></pre>
<p>If the key isn’t present in the <code>HashMap&lt;K, Option&lt;V&gt;&gt;</code>, then <code>None</code> is returned. If the key is present but the associated value is <code>None</code>, <code>Some(None)</code> is returned. Otherwise, if the key is present and the value isn’t <code>None</code>, then <code>Some(Some(value))</code> is returned. </p>
<p>The use of sum types gives us 3 distinct kinds of values that can be distinguished from one another, instead of an ambiguous null.</p>
<h3 id="extensibility-1">Extensibility</h3>
<p>Sum types can be used for optional values via <code>Option</code>-like types. But they are not limited to only this. You can define your own sum types. It’s very handy when you need to return errors (See rust <a href="https://doc.rust-lang.org/std/result/index.html"><code>Result</code></a> for example), define the errors themselves or just in general when you need to hold different kinds (types) of data in one place. </p>
<h3 id="explicitness">Explicitness</h3>
<p>There is one thing you may prefer about <code>null</code> over sum types: <code>T</code> can be <a href="https://en.wikipedia.org/wiki/Type_conversion">coerced</a> to <code>T?</code>.  That means that you don’t need to explicitly wrap values in <code>Some</code> (<code>Just</code>). </p>
<p>This may be handy, because you need to type ~6 characters less if you want to pass <code>T</code> to a function that accepts <code>T?</code>. However, I don’t think that wrapping inconvenience outweighs the benefits of sum types.</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">f</span><span>(x: </span><span style="color:#b48ead;">Int</span><span>?): </span><span style="color:#b48ead;">Int</span><span>? = x?.let { it + </span><span style="color:#d08770;">1</span><span> }
</span><span style="color:#b48ead;">val </span><span>res = f(</span><span style="color:#d08770;">1</span><span>)
</span></code></pre>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">f</span><span>(</span><span style="color:#bf616a;">x</span><span>: Option&lt;</span><span style="color:#b48ead;">i32</span><span>&gt;) -&gt; Option&lt;</span><span style="color:#b48ead;">i32</span><span>&gt; { x.</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">it</span><span>| it + </span><span style="color:#d08770;">1</span><span>) }
</span><span style="color:#b48ead;">let</span><span> res = </span><span style="color:#96b5b4;">f</span><span>(Some(</span><span style="color:#d08770;">1</span><span>));
</span><span style="color:#65737e;">//          ^^^^^ ^
</span></code></pre>
<p>It would be interesting to see a language with sum types and <code>T</code> to <code>Option&lt;T&gt;</code> coercion though 👀</p>
<h2 id="niche-optimization">Niche optimization</h2>
<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>I could only find mentions of this optimization in Rust, but I think it’s very neat anyway, so I’ll talk about Rust in this paragraph.</p>

  </div>
</div>
<p>There are some types that have unused space in their memory representation — a <em>niche</em>. For example, <code>bool</code> is only 1 bit of information, but it uses 1 byte of space, so 7 bits are unused. References (<code>&amp;T</code>, <code>&amp;mut T</code>) and <code>NonNull</code> can never be null, meaning that they have an unused bit pattern — all zeroes. The same goes with <a href="https://doc.rust-lang.org/std/num/index.html"><code>NonZero*</code></a>. Enumerations, just as <code>bool</code>, can have unused bits/bit patterns.</p>
<p>What if we could use this for something actually useful? Well, Rust can.</p>
<p>If a sum type has one of its variants being a type with a niche, then it can use it to represent other variants, instead of using a tag. I.e. <code>Option&lt;&amp;T&gt;</code> isn’t identical to <code>struct { value: union { Some(&amp;T), None }, tag: u8 }</code> (pseudo syntax), but instead it’s just <code>union { Some(&amp;T), None }</code> where the <code>None</code> is encoded as <code>0</code> (since reference can never be <code>0</code> you can distinguish variants without a <code>tag</code>). Moreover, this exact optimization of <code>Option&lt;&amp;T&gt;</code> is even <a href="https://doc.rust-lang.org/std/option/index.html#representation">guaranteed</a>, so it is fully layout compatible with <code>*const T</code>. This allows using it in C-ffi, making <code>None</code> on the Rust side a <code>null</code> on the C side.</p>
<p>This optimization can be observed using <code>mem::size_of</code> function:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// `u8`, `bool` and `Option&lt;bool&gt;` all occupy 1 byte.
</span><span style="color:#65737e;">// `Option::&lt;bool&gt;::None` is encoded as 2. It&#39;s fine, since `bool`
</span><span style="color:#65737e;">// can only ever by 1 or 0.
</span><span>size_of::&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;() = </span><span style="color:#d08770;">1
</span><span>size_of::&lt;</span><span style="color:#b48ead;">bool</span><span>&gt;() = </span><span style="color:#d08770;">1
</span><span>size_of::&lt;Option&lt;</span><span style="color:#b48ead;">bool</span><span>&gt;&gt;() = </span><span style="color:#d08770;">1
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;</span><span style="color:#b48ead;">bool</span><span>&gt;, </span><span style="color:#b48ead;">u8</span><span>&gt;(None) } = </span><span style="color:#d08770;">2
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;</span><span style="color:#b48ead;">bool</span><span>&gt;, </span><span style="color:#b48ead;">u8</span><span>&gt;(Some(</span><span style="color:#d08770;">true</span><span>)) } = </span><span style="color:#d08770;">1
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;</span><span style="color:#b48ead;">bool</span><span>&gt;, </span><span style="color:#b48ead;">u8</span><span>&gt;(Some(</span><span style="color:#d08770;">false</span><span>)) } = </span><span style="color:#d08770;">0
</span><span>
</span><span style="color:#65737e;">// `Option&lt;Option&lt;bool&gt;&gt;` behaves similarly, it just needs 2 patterns.
</span><span>size_of::&lt;Option&lt;Option&lt;</span><span style="color:#b48ead;">bool</span><span>&gt;&gt;&gt;() = </span><span style="color:#d08770;">1
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;Option&lt;</span><span style="color:#b48ead;">bool</span><span>&gt;&gt;, </span><span style="color:#b48ead;">u8</span><span>&gt;(None) } = </span><span style="color:#d08770;">3
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;Option&lt;</span><span style="color:#b48ead;">bool</span><span>&gt;&gt;, </span><span style="color:#b48ead;">u8</span><span>&gt;(Some(None)) } = </span><span style="color:#d08770;">2
</span><span>
</span><span style="color:#65737e;">// On 64 bit machines references take 8 bytes.
</span><span style="color:#65737e;">// `Option::&lt;&amp;_&gt;::None` is encoded as a `0`/`null`.
</span><span>size_of::&lt;&amp;</span><span style="color:#b48ead;">u8</span><span>&gt;() = </span><span style="color:#d08770;">8
</span><span>size_of::&lt;Option&lt;&amp;</span><span style="color:#b48ead;">u8</span><span>&gt;&gt;() = </span><span style="color:#d08770;">8
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;&amp;</span><span style="color:#b48ead;">u8</span><span>&gt;, </span><span style="color:#b48ead;">*mut u8</span><span>&gt;(None) } = </span><span style="color:#d08770;">0x0000000000000000
</span><span>
</span><span style="color:#65737e;">// `u8` has no niche, so `Option` needs a tag (in this case: first byte)
</span><span>size_of::&lt;Option&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;&gt;() = </span><span style="color:#d08770;">2
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;, Pair&lt;</span><span style="color:#b48ead;">u8</span><span>, MaybeUninit&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;&gt;&gt;(None) } = (</span><span style="color:#d08770;">0</span><span>, MaybeUninit&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;)
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;, [</span><span style="color:#b48ead;">u8</span><span>; </span><span style="color:#d08770;">2</span><span>]&gt;(Some(</span><span style="color:#d08770;">0xAA</span><span>)) } = [</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">170</span><span>]
</span><span>
</span><span style="color:#65737e;">// You may have expected 9, instead of 16, 
</span><span style="color:#65737e;">// but in Rust, size is always a multiple of the alignment.
</span><span style="color:#65737e;">// References are 8-bytes aligned. The nearest 
</span><span style="color:#65737e;">// multiple of 8 bigger than 8 is 16.
</span><span>size_of::&lt;Option&lt;Option&lt;&amp;</span><span style="color:#b48ead;">u8</span><span>&gt;&gt;&gt;() = </span><span style="color:#d08770;">16
</span><span style="color:#65737e;">// It seems like the first word is tag and the second
</span><span style="color:#65737e;">// is optional reference.
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;Option&lt;&amp;</span><span style="color:#b48ead;">u8</span><span>&gt;&gt;, Pair&lt;</span><span style="color:#b48ead;">usize</span><span>, MaybeUninit&lt;</span><span style="color:#b48ead;">usize</span><span>&gt;&gt;&gt;(None) } = (</span><span style="color:#d08770;">0</span><span>, MaybeUninit&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;)
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;Option&lt;&amp;</span><span style="color:#b48ead;">u8</span><span>&gt;&gt;, [</span><span style="color:#b48ead;">usize</span><span>; </span><span style="color:#d08770;">2</span><span>]&gt;(Some(None)) } = [</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>]
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;Option&lt;&amp;</span><span style="color:#b48ead;">u8</span><span>&gt;&gt;, [</span><span style="color:#b48ead;">usize</span><span>; </span><span style="color:#d08770;">2</span><span>]&gt;(Some(Some(&amp;</span><span style="color:#d08770;">1</span><span>))) } = [</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">93965956011124</span><span>]
</span></code></pre>
<p><em>Edited output of the <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0166b25cd98164e32879456d65a8e9b8">test program</a>.</em></p>
<h2 id="a-sad-note-kotlin">A sad note: Kotlin</h2>
<p>Kotlin <em>does</em> support sum types via <a href="https://kotlinlang.org/docs/sealed-classes.html">sealed classes</a>. Here is an example how you could define and use <code>Option</code> (<a href="https://pl.kotl.in/XZ1fBjith">play</a>): </p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">sealed class </span><span style="color:#ebcb8b;">Option</span><span>&lt;</span><span style="color:#b48ead;">T</span><span>&gt; {
</span><span>    </span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">None</span><span>&lt;</span><span style="color:#b48ead;">T</span><span>&gt;() : </span><span style="color:#a3be8c;">Option</span><span>&lt;</span><span style="color:#a3be8c;">T</span><span>&gt;() {}
</span><span>    </span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Some</span><span>&lt;</span><span style="color:#b48ead;">T</span><span>&gt;(</span><span style="color:#b48ead;">val </span><span>value: T) : </span><span style="color:#a3be8c;">Option</span><span>&lt;</span><span style="color:#a3be8c;">T</span><span>&gt;() {}
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">val </span><span>a: Option&lt;</span><span style="color:#b48ead;">Int</span><span>&gt; = Option.Some(</span><span style="color:#d08770;">12</span><span>);
</span><span>    </span><span style="color:#b48ead;">val </span><span>b = </span><span style="color:#b48ead;">when</span><span>(a) {
</span><span>        is Option.None -&gt; &quot;</span><span style="color:#a3be8c;">None</span><span>&quot;
</span><span>
</span><span>        </span><span style="color:#65737e;">// `a` is smart-casted to `Some`, so `value` is accessible.
</span><span>        </span><span style="color:#65737e;">// IMO pattern matching would be better, but that&#39;s ok.
</span><span>        is Option.Some -&gt; a.value.toString()
</span><span>    }
</span><span>    println(b)
</span><span>}
</span></code></pre>
<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>In my opinion, Kotlin’s support of sum types is extremely hacky, but who am I to say that, right?</p>

  </div>
</div>
<p>Nevertheless, Kotlin doesn’t use this for optional values! In fact, it doesn’t even have an <code>Option</code> class in the standard library. For me, it seems like a big omission. It seems like making <code>T?</code> equivalent to <code>Option&lt;T&gt;</code> and <code>Option&lt;N&gt;</code> (where <code>N</code> is not <code>Option</code>) be layout compatible with <code>Java</code>’s <code>N</code> (i.e. <code>Java</code>’s <code>null</code> being the same as <code>None&lt;N&gt;</code>) would be sufficient…</p>
<h2 id="a-sad-note-c">A sad note: C#</h2>
<p>C# doesn’t support sum types. To some extent they can be simulated using inheritance from an interface or abstract class, however, such an approach lacks one of the greatest benefits of sum types, namely the exhaustiveness check.</p>
<p>It’s especially sad since F# (which is running on the same VM) supports sum types (F# docs call them <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/discriminated-unions"><em>Discriminated Unions</em></a>), but C# doesn’t.</p>
<pre data-lang="f#" style="background-color:#2b303b;color:#c0c5ce;" class="language-f# "><code class="language-f#" data-lang="f#"><span style="color:#b48ead;">type </span><span>Option</span><span style="color:#b48ead;">&lt;</span><span>&#39;a</span><span style="color:#b48ead;">&gt; =</span><span> None </span><span style="color:#b48ead;">|</span><span> Some </span><span style="color:#b48ead;">of </span><span>&#39;a
</span><span style="color:#b48ead;">type </span><span>Either</span><span style="color:#b48ead;">&lt;</span><span>&#39;a</span><span style="color:#b48ead;">, </span><span>&#39;b</span><span style="color:#b48ead;">&gt; =</span><span> Left </span><span style="color:#b48ead;">of </span><span>&#39;a </span><span style="color:#b48ead;">|</span><span> Right </span><span style="color:#b48ead;">of </span><span>&#39;b
</span></code></pre>
<h2 id="a-sad-note-go">A sad note: Go</h2>
<p>Go doesn’t support sum types. It’s a little sad on its own, but Go also doesn’t have exceptions and all reference types are implicitly nullable. This means that if a function wants to return an error, it needs to return a tuple of success and error values. This not only makes checking which is <code>null</code> (actually <code>nil</code>, but it’s the same thing) pretty annoying, but also leaves the possibility for an invalid state where neither success nor error values are null. </p>
<p>I think it’s inexcusable to have such error-prone design flaws in 2012.</p>
<h2 id="conclusion">Conclusion</h2>
<p>There is no nice conclusion. The reality is painful as usual. We are stuck with a 56-year old abstraction that has proven itself to be error-prone for a while now. We are stuck with it, even though a better solution exists for longer than I have.</p>
<p>bye.</p>

        </div>

        
    </div>

    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright copyright--user"><div class="copyright"><span>© 2021 Maybe Waffle</span><span class="copyright-theme"><span class="copyright-theme-sep">:: </span>Theme is based on <a href="https://github.com/pawroman/zola-theme-terminimal/">Terminimal</a></span><span class="copyright-theme-sep">:: </span><a href="/rss.xml">rss</a></div></div>
            </div>
    </footer>
    

</div>
</body>

</html>
